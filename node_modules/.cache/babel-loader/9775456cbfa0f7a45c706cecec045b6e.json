{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useRef, useState } from 'react';\nimport { ApprovalContract, getNetworkContractApproval, setNetworkContractApproval } from 'services/web3/approval';\nimport { ModalApproveNew } from 'elements/modalApprove/modalApproveNew';\nimport { addNotification, NotificationType } from 'redux/notification/notification';\nimport { useDispatch } from 'react-redux';\nimport { ErrorCode } from 'services/web3/types';\nimport { wait } from 'utils/pureFunctions';\nimport { web3 } from 'services/web3';\nimport { ConversionEvents } from '../services/api/googleTagManager';\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const useApproveModal = function () {\n  _s();\n\n  let tokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let onComplete = arguments.length > 1 ? arguments[1] : undefined;\n  let contract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ApprovalContract.BancorNetwork;\n  let gtmPopupEvent = arguments.length > 3 ? arguments[3] : undefined;\n  let gtmSelectEvent = arguments.length > 4 ? arguments[4] : undefined;\n  const [isOpen, setIsOpen] = useState(false);\n  const [tokenIndex, setTokenIndex] = useState(0);\n  const [isLoading, setIsLoading] = useState(false);\n  const ref = useRef([]);\n  const awaitConfirmation = useCallback(async () => {\n    const receipts = [];\n\n    for (const txHash of ref.current) {\n      try {\n        const receipt = await web3.provider.getTransactionReceipt(txHash);\n        receipts.push(receipt);\n      } catch (e) {\n        console.error('failed to getTransactionReceipt for approve token tx');\n        return;\n      }\n    }\n\n    const successCount = receipts.filter(r => r && r.status).length;\n\n    if (successCount === ref.current.length) {\n      ref.current = [];\n      onComplete();\n    } else {\n      await wait(3000);\n      await awaitConfirmation();\n    }\n  }, [onComplete]);\n  const dispatch = useDispatch();\n\n  const onStart = async () => {\n    if (tokens.length === 0) {\n      console.error('No tokens provided for approval!');\n      return;\n    }\n\n    await checkApprovalRequired();\n  };\n\n  if (tokens.length === 0) return [onStart, /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false)];\n\n  const checkNextToken = async function () {\n    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : tokenIndex;\n    const nextIndex = index + 1;\n    const count = tokens.length;\n\n    if (count === nextIndex) {\n      return awaitConfirmation();\n    }\n\n    await wait(500);\n    setTokenIndex(nextIndex);\n    return checkApprovalRequired(nextIndex);\n  };\n\n  const checkApprovalRequired = async function () {\n    let tokenIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const {\n      token,\n      amount\n    } = tokens[tokenIndex];\n    const isApprovalRequired = await getNetworkContractApproval(token, contract, amount);\n\n    if (!isApprovalRequired) {\n      return checkNextToken(tokenIndex);\n    }\n\n    gtmPopupEvent && gtmPopupEvent(ConversionEvents.approvePop);\n    setIsOpen(true);\n  };\n\n  const setApproval = async amount => {\n    if (gtmSelectEvent) {\n      const isUnlimited = amount === undefined;\n      gtmSelectEvent(isUnlimited);\n    }\n\n    const {\n      token\n    } = tokens[tokenIndex];\n\n    try {\n      setIsLoading(true);\n      const txHash = await setNetworkContractApproval(token, contract, amount, true);\n      ref.current = [...ref.current, txHash];\n      dispatch(addNotification({\n        type: NotificationType.pending,\n        title: 'Pending Confirmation',\n        msg: `Approve ${tokens[tokenIndex].token.symbol} is pending confirmation`,\n        updatedInfo: {\n          successTitle: 'Transaction Confirmed',\n          successMsg: `${amount || 'Unlimited'} approval set for ${tokens[tokenIndex].token.symbol}`,\n          errorTitle: 'Transaction Failed',\n          errorMsg: `${tokens[tokenIndex].token.symbol} approval had failed. Please try again or contact support.`\n        },\n        txHash\n      }));\n      setIsOpen(false);\n      setIsLoading(false);\n      await checkNextToken();\n    } catch (e) {\n      if (e.code === ErrorCode.DeniedTx) {\n        dispatch(addNotification({\n          type: NotificationType.error,\n          title: 'Transaction Rejected',\n          msg: 'You rejected the transaction. If this was by mistake, please try again.'\n        }));\n      } else {\n        dispatch(addNotification({\n          type: NotificationType.error,\n          title: 'Transaction Failed',\n          msg: `${tokens[tokenIndex].token.symbol} approval had failed. Please try again or contact support.`\n        }));\n      }\n\n      setIsOpen(false);\n      setIsLoading(false);\n    }\n  };\n\n  const ModalApprove = ModalApproveNew({\n    isOpen,\n    setIsOpen,\n    amount: tokens[tokenIndex].amount,\n    setApproval,\n    token: tokens[tokenIndex].token,\n    isLoading\n  });\n  return [onStart, ModalApprove];\n};\n\n_s(useApproveModal, \"zHiAm0wLbeWNOPJb0B3BomLlJPI=\", false, function () {\n  return [useDispatch];\n});","map":{"version":3,"sources":["/Users/safahi/Desktop/webapp-v2-feature-gtm_events/src/hooks/useApproveModal.tsx"],"names":["useCallback","useRef","useState","ApprovalContract","getNetworkContractApproval","setNetworkContractApproval","ModalApproveNew","addNotification","NotificationType","useDispatch","ErrorCode","wait","web3","ConversionEvents","useApproveModal","tokens","onComplete","contract","BancorNetwork","gtmPopupEvent","gtmSelectEvent","isOpen","setIsOpen","tokenIndex","setTokenIndex","isLoading","setIsLoading","ref","awaitConfirmation","receipts","txHash","current","receipt","provider","getTransactionReceipt","push","e","console","error","successCount","filter","r","status","length","dispatch","onStart","checkApprovalRequired","checkNextToken","index","nextIndex","count","token","amount","isApprovalRequired","approvePop","setApproval","isUnlimited","undefined","type","pending","title","msg","symbol","updatedInfo","successTitle","successMsg","errorTitle","errorMsg","code","DeniedTx","ModalApprove"],"mappings":"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","sourcesContent":["import { Token } from 'services/observables/tokens';\nimport { useCallback, useRef, useState } from 'react';\nimport {\n  ApprovalContract,\n  getNetworkContractApproval,\n  setNetworkContractApproval,\n} from 'services/web3/approval';\nimport { ModalApproveNew } from 'elements/modalApprove/modalApproveNew';\nimport {\n  addNotification,\n  NotificationType,\n} from 'redux/notification/notification';\nimport { useDispatch } from 'react-redux';\nimport { ErrorCode } from 'services/web3/types';\nimport { wait } from 'utils/pureFunctions';\nimport { web3 } from 'services/web3';\nimport { ConversionEvents } from '../services/api/googleTagManager';\n\ninterface Tokens {\n  token: Token;\n  amount: string;\n}\n\nexport const useApproveModal = (\n  tokens: Tokens[] = [],\n  onComplete: Function,\n  contract: ApprovalContract | string = ApprovalContract.BancorNetwork,\n  gtmPopupEvent?: (event: ConversionEvents) => void,\n  gtmSelectEvent?: (isUnlimited: boolean) => void\n) => {\n  const [isOpen, setIsOpen] = useState(false);\n  const [tokenIndex, setTokenIndex] = useState(0);\n  const [isLoading, setIsLoading] = useState(false);\n  const ref = useRef<string[]>([]);\n\n  const awaitConfirmation = useCallback(async () => {\n    const receipts = [];\n    for (const txHash of ref.current) {\n      try {\n        const receipt = await web3.provider.getTransactionReceipt(txHash);\n        receipts.push(receipt);\n      } catch (e: any) {\n        console.error('failed to getTransactionReceipt for approve token tx');\n        return;\n      }\n    }\n\n    const successCount = receipts.filter((r) => r && r.status).length;\n    if (successCount === ref.current.length) {\n      ref.current = [];\n      onComplete();\n    } else {\n      await wait(3000);\n      await awaitConfirmation();\n    }\n  }, [onComplete]);\n\n  const dispatch = useDispatch();\n\n  const onStart = async () => {\n    if (tokens.length === 0) {\n      console.error('No tokens provided for approval!');\n      return;\n    }\n    await checkApprovalRequired();\n  };\n\n  if (tokens.length === 0) return [onStart, <></>] as [Function, JSX.Element];\n\n  const checkNextToken = async (index = tokenIndex): Promise<any> => {\n    const nextIndex = index + 1;\n    const count = tokens.length;\n    if (count === nextIndex) {\n      return awaitConfirmation();\n    }\n    await wait(500);\n    setTokenIndex(nextIndex);\n    return checkApprovalRequired(nextIndex);\n  };\n\n  const checkApprovalRequired = async (tokenIndex: number = 0) => {\n    const { token, amount } = tokens[tokenIndex];\n    const isApprovalRequired = await getNetworkContractApproval(\n      token,\n      contract,\n      amount\n    );\n\n    if (!isApprovalRequired) {\n      return checkNextToken(tokenIndex);\n    }\n\n    gtmPopupEvent && gtmPopupEvent(ConversionEvents.approvePop);\n\n    setIsOpen(true);\n  };\n\n  const setApproval = async (amount?: string) => {\n    if (gtmSelectEvent) {\n      const isUnlimited = amount === undefined;\n      gtmSelectEvent(isUnlimited);\n    }\n    const { token } = tokens[tokenIndex];\n    try {\n      setIsLoading(true);\n      const txHash = await setNetworkContractApproval(\n        token,\n        contract,\n        amount,\n        true\n      );\n\n      ref.current = [...ref.current, txHash];\n      dispatch(\n        addNotification({\n          type: NotificationType.pending,\n          title: 'Pending Confirmation',\n          msg: `Approve ${tokens[tokenIndex].token.symbol} is pending confirmation`,\n          updatedInfo: {\n            successTitle: 'Transaction Confirmed',\n            successMsg: `${amount || 'Unlimited'} approval set for ${\n              tokens[tokenIndex].token.symbol\n            }`,\n            errorTitle: 'Transaction Failed',\n            errorMsg: `${tokens[tokenIndex].token.symbol} approval had failed. Please try again or contact support.`,\n          },\n          txHash,\n        })\n      );\n      setIsOpen(false);\n      setIsLoading(false);\n\n      await checkNextToken();\n    } catch (e: any) {\n      if (e.code === ErrorCode.DeniedTx) {\n        dispatch(\n          addNotification({\n            type: NotificationType.error,\n            title: 'Transaction Rejected',\n            msg: 'You rejected the transaction. If this was by mistake, please try again.',\n          })\n        );\n      } else {\n        dispatch(\n          addNotification({\n            type: NotificationType.error,\n            title: 'Transaction Failed',\n            msg: `${tokens[tokenIndex].token.symbol} approval had failed. Please try again or contact support.`,\n          })\n        );\n      }\n\n      setIsOpen(false);\n      setIsLoading(false);\n    }\n  };\n\n  const ModalApprove = ModalApproveNew({\n    isOpen,\n    setIsOpen,\n    amount: tokens[tokenIndex].amount,\n    setApproval,\n    token: tokens[tokenIndex].token,\n    isLoading,\n  });\n\n  return [onStart, ModalApprove] as [Function, JSX.Element];\n};\n"]},"metadata":{},"sourceType":"module"}