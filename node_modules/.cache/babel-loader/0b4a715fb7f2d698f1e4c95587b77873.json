{"ast":null,"code":"import { getWelcomeData } from 'services/api/bancor';\nimport { isEqual, zip } from 'lodash';\nimport { combineLatest } from 'rxjs';\nimport { distinctUntilChanged, map, pluck, shareReplay, startWith } from 'rxjs/operators';\nimport { bancorConverterRegistry$ } from './contracts';\nimport { switchMapIgnoreThrow } from './customOperators';\nimport { currentNetwork$ } from './network';\nimport { fifteenSeconds$ } from './timers';\nimport { web3 } from 'services/web3';\nimport { utils } from 'ethers';\nimport { updateArray } from 'utils/pureFunctions';\nimport { ConverterRegistry__factory } from 'services/web3/abis/types';\nimport { user$ } from './user';\nimport { multicall } from 'services/web3/multicall/multicall';\nimport { buildTokenBalanceCall, buildTokenTotalSupplyCall } from './balances';\nexport const apiData$ = combineLatest([currentNetwork$, fifteenSeconds$]).pipe(switchMapIgnoreThrow(_ref => {\n  let [networkVersion] = _ref;\n  return getWelcomeData(networkVersion);\n}), shareReplay(1));\nexport const apiTokens$ = apiData$.pipe(pluck('tokens'), distinctUntilChanged(isEqual), shareReplay(1));\nconst trueAnchors$ = bancorConverterRegistry$.pipe(switchMapIgnoreThrow(async converterRegistry => {\n  const contract = ConverterRegistry__factory.connect(converterRegistry, web3.provider);\n  return await contract.getAnchors();\n}), shareReplay(1));\nconst anchorAndConverters$ = combineLatest([trueAnchors$, bancorConverterRegistry$]).pipe(switchMapIgnoreThrow(async _ref2 => {\n  let [anchorAddresses, converterRegistryAddress] = _ref2;\n  const contract = ConverterRegistry__factory.connect(converterRegistryAddress, web3.provider);\n  const converters = await contract.getConvertersByAnchors(anchorAddresses);\n  const anchorsAndConverters = zipAnchorAndConverters(anchorAddresses, converters);\n  return anchorsAndConverters;\n}), startWith([]), shareReplay(1));\nconst apiPools$ = apiData$.pipe(pluck('pools'), distinctUntilChanged(isEqual), shareReplay(1));\nexport const partialPoolTokens$ = combineLatest([anchorAndConverters$, user$]).pipe(switchMapIgnoreThrow(async _ref3 => {\n  let [anchorAndConverters, user] = _ref3;\n  if (!user) return [];\n  const calls = anchorAndConverters.map(x => buildTokenBalanceCall(x.anchorAddress, user));\n  const res = await multicall(calls);\n\n  if (res) {\n    const partialPTokens = res.map((x, index) => {\n      const anchorConverter = anchorAndConverters[index];\n      return {\n        balance: x.length > 0 ? x[0].toString() : '0',\n        anchor: anchorConverter.anchorAddress,\n        converter: anchorConverter.converterAddress\n      };\n    }).filter(x => x.balance !== '0');\n    const calls = partialPTokens.map(x => buildTokenTotalSupplyCall(x.anchor));\n    const total = await multicall(calls);\n\n    if (total) {\n      return partialPTokens.map((token, index) => ({\n        totalSupply: total[index].toString(),\n        ...token\n      }));\n    }\n  }\n\n  return [];\n}));\nexport const correctedPools$ = combineLatest([apiPools$, anchorAndConverters$]).pipe(map(_ref4 => {\n  let [pools, anchorAndConverters] = _ref4;\n  if (anchorAndConverters.length === 0) return pools;\n  return updateArray(pools, pool => {\n    const correctAnchor = anchorAndConverters.find(anchor => anchor.anchorAddress === pool.pool_dlt_id);\n    if (!correctAnchor) return false;\n    return correctAnchor.converterAddress !== pool.converter_dlt_id;\n  }, pool => {\n    const correctAnchor = anchorAndConverters.find(anchor => anchor.anchorAddress === pool.pool_dlt_id);\n    return { ...pool,\n      converter_dlt_id: correctAnchor.converterAddress\n    };\n  });\n}), distinctUntilChanged(isEqual), shareReplay(1));\n\nconst zipAnchorAndConverters = (anchorAddresses, converterAddresses) => {\n  if (anchorAddresses.length !== converterAddresses.length) throw new Error('was expecting as many anchor addresses as converter addresses');\n  const zipped = zip(anchorAddresses, converterAddresses);\n  return zipped.map(_ref5 => {\n    let [anchorAddress, converterAddress] = _ref5;\n    return {\n      anchorAddress: utils.getAddress(anchorAddress),\n      converterAddress: utils.getAddress(converterAddress)\n    };\n  });\n};","map":{"version":3,"sources":["/Users/safahi/Desktop/webapp-v2-feature-gtm_events/src/services/observables/pools.ts"],"names":["getWelcomeData","isEqual","zip","combineLatest","distinctUntilChanged","map","pluck","shareReplay","startWith","bancorConverterRegistry$","switchMapIgnoreThrow","currentNetwork$","fifteenSeconds$","web3","utils","updateArray","ConverterRegistry__factory","user$","multicall","buildTokenBalanceCall","buildTokenTotalSupplyCall","apiData$","pipe","networkVersion","apiTokens$","trueAnchors$","converterRegistry","contract","connect","provider","getAnchors","anchorAndConverters$","anchorAddresses","converterRegistryAddress","converters","getConvertersByAnchors","anchorsAndConverters","zipAnchorAndConverters","apiPools$","partialPoolTokens$","anchorAndConverters","user","calls","x","anchorAddress","res","partialPTokens","index","anchorConverter","balance","length","toString","anchor","converter","converterAddress","filter","total","token","totalSupply","correctedPools$","pools","pool","correctAnchor","find","pool_dlt_id","converter_dlt_id","converterAddresses","Error","zipped","getAddress"],"mappings":"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","sourcesContent":["import { getWelcomeData, WelcomeData } from 'services/api/bancor';\nimport { isEqual, zip } from 'lodash';\nimport { combineLatest } from 'rxjs';\nimport {\n  distinctUntilChanged,\n  map,\n  pluck,\n  shareReplay,\n  startWith,\n} from 'rxjs/operators';\nimport { ConverterAndAnchor } from 'services/web3/types';\nimport { bancorConverterRegistry$ } from './contracts';\nimport { switchMapIgnoreThrow } from './customOperators';\nimport { currentNetwork$ } from './network';\nimport { fifteenSeconds$ } from './timers';\nimport { web3 } from 'services/web3';\nimport { BigNumber, utils } from 'ethers';\nimport { updateArray } from 'utils/pureFunctions';\nimport { ConverterRegistry__factory } from 'services/web3/abis/types';\nimport { user$ } from './user';\nimport { multicall } from 'services/web3/multicall/multicall';\nimport { buildTokenBalanceCall, buildTokenTotalSupplyCall } from './balances';\n\nexport const apiData$ = combineLatest([currentNetwork$, fifteenSeconds$]).pipe(\n  switchMapIgnoreThrow(([networkVersion]) => getWelcomeData(networkVersion)),\n  shareReplay(1)\n);\n\nexport const apiTokens$ = apiData$.pipe(\n  pluck('tokens'),\n  distinctUntilChanged<WelcomeData['tokens']>(isEqual),\n  shareReplay(1)\n);\n\nconst trueAnchors$ = bancorConverterRegistry$.pipe(\n  switchMapIgnoreThrow(async (converterRegistry) => {\n    const contract = ConverterRegistry__factory.connect(\n      converterRegistry,\n      web3.provider\n    );\n    return await contract.getAnchors();\n  }),\n  shareReplay(1)\n);\n\nconst anchorAndConverters$ = combineLatest([\n  trueAnchors$,\n  bancorConverterRegistry$,\n]).pipe(\n  switchMapIgnoreThrow(async ([anchorAddresses, converterRegistryAddress]) => {\n    const contract = ConverterRegistry__factory.connect(\n      converterRegistryAddress,\n      web3.provider\n    );\n\n    const converters = await contract.getConvertersByAnchors(anchorAddresses);\n    const anchorsAndConverters = zipAnchorAndConverters(\n      anchorAddresses,\n      converters\n    );\n    return anchorsAndConverters;\n  }),\n  startWith([] as ConverterAndAnchor[]),\n  shareReplay(1)\n);\n\nconst apiPools$ = apiData$.pipe(\n  pluck('pools'),\n  distinctUntilChanged<WelcomeData['pools']>(isEqual),\n  shareReplay(1)\n);\n\nexport const partialPoolTokens$ = combineLatest([\n  anchorAndConverters$,\n  user$,\n]).pipe(\n  switchMapIgnoreThrow(async ([anchorAndConverters, user]) => {\n    if (!user) return [];\n\n    const calls = anchorAndConverters.map((x) =>\n      buildTokenBalanceCall(x.anchorAddress, user)\n    );\n\n    const res = await multicall(calls);\n    if (res) {\n      const partialPTokens = res\n        .map((x, index) => {\n          const anchorConverter = anchorAndConverters[index];\n          return {\n            balance: x.length > 0 ? (x[0] as BigNumber).toString() : '0',\n            anchor: anchorConverter.anchorAddress,\n            converter: anchorConverter.converterAddress,\n          };\n        })\n        .filter((x) => x.balance !== '0');\n\n      const calls = partialPTokens.map((x) =>\n        buildTokenTotalSupplyCall(x.anchor)\n      );\n      const total = await multicall(calls);\n      if (total) {\n        return partialPTokens.map((token, index) => ({\n          totalSupply: total[index].toString(),\n          ...token,\n        }));\n      }\n    }\n\n    return [];\n  })\n);\n\nexport const correctedPools$ = combineLatest([\n  apiPools$,\n  anchorAndConverters$,\n]).pipe(\n  map(([pools, anchorAndConverters]) => {\n    if (anchorAndConverters.length === 0) return pools;\n    return updateArray(\n      pools,\n      (pool) => {\n        const correctAnchor = anchorAndConverters.find(\n          (anchor) => anchor.anchorAddress === pool.pool_dlt_id\n        );\n        if (!correctAnchor) return false;\n        return correctAnchor.converterAddress !== pool.converter_dlt_id;\n      },\n      (pool) => {\n        const correctAnchor = anchorAndConverters.find(\n          (anchor) => anchor.anchorAddress === pool.pool_dlt_id\n        )!;\n        return {\n          ...pool,\n          converter_dlt_id: correctAnchor.converterAddress,\n        };\n      }\n    );\n  }),\n  distinctUntilChanged<WelcomeData['pools']>(isEqual),\n  shareReplay(1)\n);\n\nconst zipAnchorAndConverters = (\n  anchorAddresses: string[],\n  converterAddresses: string[]\n): ConverterAndAnchor[] => {\n  if (anchorAddresses.length !== converterAddresses.length)\n    throw new Error(\n      'was expecting as many anchor addresses as converter addresses'\n    );\n\n  const zipped = zip(anchorAddresses, converterAddresses) as [string, string][];\n  return zipped.map(([anchorAddress, converterAddress]) => ({\n    anchorAddress: utils.getAddress(anchorAddress!),\n    converterAddress: utils.getAddress(converterAddress!),\n  }));\n};\n"]},"metadata":{},"sourceType":"module"}