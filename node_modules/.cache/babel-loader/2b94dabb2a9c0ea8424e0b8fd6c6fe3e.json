{"ast":null,"code":"import { switchMapIgnoreThrow } from './customOperators';\nimport { currentNetwork$, networkVars$ } from './network';\nimport { distinctUntilChanged, map, pluck, shareReplay, switchMap } from 'rxjs/operators';\nimport { isEqual } from 'lodash';\nimport { getContractAddressesForChainOrThrow } from '@0x/contract-addresses';\nimport { utils } from 'ethers';\nimport { ContractRegistry__factory, LiquidityProtection__factory } from 'services/web3/abis/types';\nimport { web3 } from 'services/web3';\nimport { multicall } from 'services/web3/multicall/multicall';\nconst zeroXContracts$ = currentNetwork$.pipe(switchMapIgnoreThrow(async currentNetwork => getContractAddressesForChainOrThrow(currentNetwork)));\nexport const exchangeProxy$ = zeroXContracts$.pipe(pluck('exchangeProxy'), map(utils.getAddress), shareReplay(1));\nexport const contractAddresses$ = networkVars$.pipe(switchMapIgnoreThrow(networkVariables => fetchContractAddresses(networkVariables)), distinctUntilChanged(isEqual), shareReplay(1));\n\nconst fetchContractAddresses = async networkVariables => {\n  const contract = ContractRegistry__factory.connect(networkVariables.contractRegistry, web3.provider);\n\n  try {\n    const addresses = await multicall([buildAddressCall(contract, 'BancorNetwork'), buildAddressCall(contract, 'BancorConverterRegistry'), buildAddressCall(contract, 'LiquidityProtectionStore'), buildAddressCall(contract, 'LiquidityProtection'), buildAddressCall(contract, 'StakingRewards')]);\n    if (addresses) return {\n      BancorNetwork: addresses[0].toString(),\n      BancorConverterRegistry: addresses[1].toString(),\n      LiquidityProtectionStore: addresses[2].toString(),\n      LiquidityProtection: addresses[3].toString(),\n      StakingRewards: addresses[4].toString()\n    };\n  } catch (error) {\n    console.error(error);\n  }\n\n  return {\n    BancorNetwork: '',\n    BancorConverterRegistry: '',\n    LiquidityProtectionStore: '',\n    LiquidityProtection: '',\n    StakingRewards: ''\n  };\n};\n\nconst buildAddressCall = (registry, contract) => ({\n  contractAddress: registry.address,\n  interface: registry.interface,\n  methodName: 'addressOf',\n  methodParameters: [utils.formatBytes32String(contract)]\n});\n\nexport const bancorNetwork$ = contractAddresses$.pipe(pluck('BancorNetwork'));\nexport const liquidityProtection$ = contractAddresses$.pipe(pluck('LiquidityProtection'));\nexport const bancorConverterRegistry$ = contractAddresses$.pipe(pluck('BancorConverterRegistry'));\nexport const stakingRewards$ = contractAddresses$.pipe(pluck('StakingRewards'));\nexport const liquidityProtectionStore$ = liquidityProtection$.pipe(switchMap(async liquidityProtection => {\n  const contract = LiquidityProtection__factory.connect(liquidityProtection, web3.provider);\n\n  try {\n    return await contract.store();\n  } catch (error) {\n    console.error(error);\n  }\n\n  return '';\n}), map(utils.getAddress), distinctUntilChanged(), shareReplay(1));\nexport const settingsContractAddress$ = liquidityProtection$.pipe(switchMap(async liquidityProtection => {\n  const contract = LiquidityProtection__factory.connect(liquidityProtection, web3.provider);\n\n  try {\n    return utils.getAddress(await contract.settings());\n  } catch (error) {\n    console.error(error);\n  }\n\n  return '';\n}), shareReplay(1));\nexport const systemStoreAddress$ = liquidityProtection$.pipe(switchMap(async liquidityProtection => {\n  const contract = LiquidityProtection__factory.connect(liquidityProtection, web3.provider);\n\n  try {\n    return utils.getAddress(await contract.systemStore());\n  } catch (error) {\n    console.error(error);\n  }\n\n  return '';\n}), shareReplay(1));","map":{"version":3,"sources":["/Users/safahi/Desktop/webapp-v2-feature-gtm_events/src/services/observables/contracts.ts"],"names":["switchMapIgnoreThrow","currentNetwork$","networkVars$","distinctUntilChanged","map","pluck","shareReplay","switchMap","isEqual","getContractAddressesForChainOrThrow","utils","ContractRegistry__factory","LiquidityProtection__factory","web3","multicall","zeroXContracts$","pipe","currentNetwork","exchangeProxy$","getAddress","contractAddresses$","networkVariables","fetchContractAddresses","contract","connect","contractRegistry","provider","addresses","buildAddressCall","BancorNetwork","toString","BancorConverterRegistry","LiquidityProtectionStore","LiquidityProtection","StakingRewards","error","console","registry","contractAddress","address","interface","methodName","methodParameters","formatBytes32String","bancorNetwork$","liquidityProtection$","bancorConverterRegistry$","stakingRewards$","liquidityProtectionStore$","liquidityProtection","store","settingsContractAddress$","settings","systemStoreAddress$","systemStore"],"mappings":"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","sourcesContent":["import { switchMapIgnoreThrow } from './customOperators';\nimport { currentNetwork$, networkVars$ } from './network';\nimport {\n  distinctUntilChanged,\n  map,\n  pluck,\n  shareReplay,\n  switchMap,\n} from 'rxjs/operators';\nimport { isEqual } from 'lodash';\nimport { getContractAddressesForChainOrThrow } from '@0x/contract-addresses';\nimport { Contract, utils } from 'ethers';\nimport { RegisteredContracts } from 'services/web3/types';\nimport {\n  ContractRegistry__factory,\n  LiquidityProtection__factory,\n} from 'services/web3/abis/types';\nimport { web3 } from 'services/web3';\nimport { EthNetworkVariables } from 'services/web3/config';\nimport { multicall } from 'services/web3/multicall/multicall';\n\nconst zeroXContracts$ = currentNetwork$.pipe(\n  switchMapIgnoreThrow(async (currentNetwork) =>\n    getContractAddressesForChainOrThrow(currentNetwork as number)\n  )\n);\n\nexport const exchangeProxy$ = zeroXContracts$.pipe(\n  pluck('exchangeProxy'),\n  map(utils.getAddress),\n  shareReplay(1)\n);\n\nexport const contractAddresses$ = networkVars$.pipe(\n  switchMapIgnoreThrow((networkVariables) =>\n    fetchContractAddresses(networkVariables)\n  ),\n  distinctUntilChanged<RegisteredContracts>(isEqual),\n  shareReplay(1)\n);\nconst fetchContractAddresses = async (\n  networkVariables: EthNetworkVariables\n): Promise<RegisteredContracts> => {\n  const contract = ContractRegistry__factory.connect(\n    networkVariables.contractRegistry,\n    web3.provider\n  );\n\n  try {\n    const addresses = await multicall([\n      buildAddressCall(contract, 'BancorNetwork'),\n      buildAddressCall(contract, 'BancorConverterRegistry'),\n      buildAddressCall(contract, 'LiquidityProtectionStore'),\n      buildAddressCall(contract, 'LiquidityProtection'),\n      buildAddressCall(contract, 'StakingRewards'),\n    ]);\n\n    if (addresses)\n      return {\n        BancorNetwork: addresses[0].toString(),\n        BancorConverterRegistry: addresses[1].toString(),\n        LiquidityProtectionStore: addresses[2].toString(),\n        LiquidityProtection: addresses[3].toString(),\n        StakingRewards: addresses[4].toString(),\n      };\n  } catch (error) {\n    console.error(error);\n  }\n  return {\n    BancorNetwork: '',\n    BancorConverterRegistry: '',\n    LiquidityProtectionStore: '',\n    LiquidityProtection: '',\n    StakingRewards: '',\n  };\n};\n\nconst buildAddressCall = (registry: Contract, contract: string) => ({\n  contractAddress: registry.address,\n  interface: registry.interface,\n  methodName: 'addressOf',\n  methodParameters: [utils.formatBytes32String(contract)],\n});\n\nexport const bancorNetwork$ = contractAddresses$.pipe(pluck('BancorNetwork'));\n\nexport const liquidityProtection$ = contractAddresses$.pipe(\n  pluck('LiquidityProtection')\n);\n\nexport const bancorConverterRegistry$ = contractAddresses$.pipe(\n  pluck('BancorConverterRegistry')\n);\n\nexport const stakingRewards$ = contractAddresses$.pipe(pluck('StakingRewards'));\n\nexport const liquidityProtectionStore$ = liquidityProtection$.pipe(\n  switchMap(async (liquidityProtection) => {\n    const contract = LiquidityProtection__factory.connect(\n      liquidityProtection,\n      web3.provider\n    );\n    try {\n      return await contract.store();\n    } catch (error) {\n      console.error(error);\n    }\n\n    return '';\n  }),\n  map(utils.getAddress),\n  distinctUntilChanged(),\n  shareReplay(1)\n);\n\nexport const settingsContractAddress$ = liquidityProtection$.pipe(\n  switchMap(async (liquidityProtection) => {\n    const contract = LiquidityProtection__factory.connect(\n      liquidityProtection,\n      web3.provider\n    );\n\n    try {\n      return utils.getAddress(await contract.settings());\n    } catch (error) {\n      console.error(error);\n    }\n\n    return '';\n  }),\n  shareReplay(1)\n);\n\nexport const systemStoreAddress$ = liquidityProtection$.pipe(\n  switchMap(async (liquidityProtection) => {\n    const contract = LiquidityProtection__factory.connect(\n      liquidityProtection,\n      web3.provider\n    );\n\n    try {\n      return utils.getAddress(await contract.systemStore());\n    } catch (error) {\n      console.error(error);\n    }\n\n    return '';\n  }),\n  shareReplay(1)\n);\n"]},"metadata":{},"sourceType":"module"}