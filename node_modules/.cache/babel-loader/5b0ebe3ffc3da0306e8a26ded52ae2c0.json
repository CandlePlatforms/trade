{"ast":null,"code":"import { web3, writeWeb3 } from 'services/web3';\nimport BigNumber from 'bignumber.js';\nimport { bancorNetwork$, exchangeProxy$, liquidityProtection$ } from 'services/observables/contracts';\nimport { take } from 'rxjs/operators';\nimport { user$ } from 'services/observables/user';\nimport { NULL_APPROVAL_CONTRACTS, UNLIMITED_WEI } from 'services/web3/approval/constants';\nimport { ethToken, getNetworkVariables } from 'services/web3/config';\nimport { expandToken } from 'utils/formulas';\nimport { Token__factory } from '../abis/types';\nimport { currentNetwork$ } from 'services/observables/network';\nexport let ApprovalContract;\n\n(function (ApprovalContract) {\n  ApprovalContract[ApprovalContract[\"BancorNetwork\"] = 0] = \"BancorNetwork\";\n  ApprovalContract[ApprovalContract[\"ExchangeProxy\"] = 1] = \"ExchangeProxy\";\n  ApprovalContract[ApprovalContract[\"LiquidityProtection\"] = 2] = \"LiquidityProtection\";\n  ApprovalContract[ApprovalContract[\"Governance\"] = 3] = \"Governance\";\n})(ApprovalContract || (ApprovalContract = {}));\n\nconst getApproval = async (token, user, spender, amountWei) => {\n  if (token === ethToken) return {\n    allowanceWei: '',\n    isApprovalRequired: false\n  };\n  const tokenContract = Token__factory.connect(token, web3.provider);\n  const allowanceWei = (await tokenContract.allowance(user, spender)).toString();\n  const isApprovalRequired = new BigNumber(amountWei).gt(new BigNumber(allowanceWei));\n  return {\n    allowanceWei,\n    isApprovalRequired\n  };\n};\n\nconst setApproval = async (token, user, spender, amountWei, resolveImmediately) => {\n  const isEth = token === ethToken;\n  if (isEth) return '';\n  const tokenContract = Token__factory.connect(token, writeWeb3.signer);\n  const amountFinal = amountWei ? amountWei : UNLIMITED_WEI;\n  const isNullApprovalContract = NULL_APPROVAL_CONTRACTS.includes(token);\n\n  if (isNullApprovalContract) {\n    const {\n      allowanceWei\n    } = await getApproval(token, user, spender, amountFinal);\n\n    if (Number(allowanceWei) !== 0) {\n      const tx = await tokenContract.approve(spender, '0');\n      await tx.wait();\n    }\n  }\n\n  try {\n    const tx = await tokenContract.approve(spender, amountFinal);\n    if (!resolveImmediately) await tx.wait();\n    return tx.hash;\n  } catch (e) {\n    const isTxDenied = e.message.toLowerCase().includes('denied');\n\n    if (!isTxDenied) {\n      // TODO send this error with failed contract to Sentry or GTM\n      NULL_APPROVAL_CONTRACTS.push(token);\n      console.error('Approval had failed, next try forcing a zero approval in case required', e.message);\n    }\n\n    throw e;\n  }\n};\n\nexport const getNetworkContractApproval = async (token, contract, amount) => {\n  const user = await user$.pipe(take(1)).toPromise();\n  const amountWei = expandToken(amount, token.decimals);\n  const {\n    isApprovalRequired\n  } = await getApproval(token.address, user, await getApprovalAddress(contract), amountWei);\n  return isApprovalRequired;\n};\nexport const setNetworkContractApproval = async (token, contract, amount, resolveImmediately) => {\n  const user = await user$.pipe(take(1)).toPromise();\n  const amountWei = amount ? expandToken(amount, token.decimals) : undefined;\n  return await setApproval(token.address, user, await getApprovalAddress(contract), amountWei, resolveImmediately);\n};\n\nconst getApprovalAddress = async contract => {\n  if (typeof contract === 'string') return contract;\n\n  switch (contract) {\n    case ApprovalContract.BancorNetwork:\n      return await bancorNetwork$.pipe(take(1)).toPromise();\n\n    case ApprovalContract.ExchangeProxy:\n      return await exchangeProxy$.pipe(take(1)).toPromise();\n\n    case ApprovalContract.LiquidityProtection:\n      return await liquidityProtection$.pipe(take(1)).toPromise();\n\n    case ApprovalContract.Governance:\n      const network = await currentNetwork$.pipe(take(1)).toPromise();\n      return getNetworkVariables(network).governanceContractAddress;\n  }\n};","map":{"version":3,"sources":["/Users/safahi/Desktop/webapp-v2-feature-gtm_events/src/services/web3/approval/index.ts"],"names":["web3","writeWeb3","BigNumber","bancorNetwork$","exchangeProxy$","liquidityProtection$","take","user$","NULL_APPROVAL_CONTRACTS","UNLIMITED_WEI","ethToken","getNetworkVariables","expandToken","Token__factory","currentNetwork$","ApprovalContract","getApproval","token","user","spender","amountWei","allowanceWei","isApprovalRequired","tokenContract","connect","provider","allowance","toString","gt","setApproval","resolveImmediately","isEth","signer","amountFinal","isNullApprovalContract","includes","Number","tx","approve","wait","hash","e","isTxDenied","message","toLowerCase","push","console","error","getNetworkContractApproval","contract","amount","pipe","toPromise","decimals","address","getApprovalAddress","setNetworkContractApproval","undefined","BancorNetwork","ExchangeProxy","LiquidityProtection","Governance","network","governanceContractAddress"],"mappings":"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","sourcesContent":["import { Token } from 'services/observables/tokens';\nimport { web3, writeWeb3 } from 'services/web3';\nimport BigNumber from 'bignumber.js';\nimport {\n  bancorNetwork$,\n  exchangeProxy$,\n  liquidityProtection$,\n} from 'services/observables/contracts';\nimport { take } from 'rxjs/operators';\nimport { user$ } from 'services/observables/user';\nimport {\n  NULL_APPROVAL_CONTRACTS,\n  UNLIMITED_WEI,\n} from 'services/web3/approval/constants';\nimport { ethToken, getNetworkVariables } from 'services/web3/config';\nimport { expandToken } from 'utils/formulas';\nimport { Token__factory } from '../abis/types';\nimport { currentNetwork$ } from 'services/observables/network';\n\ninterface GetApprovalReturn {\n  allowanceWei: string;\n  isApprovalRequired: boolean;\n}\n\nexport enum ApprovalContract {\n  BancorNetwork,\n  ExchangeProxy,\n  LiquidityProtection,\n  Governance,\n}\n\nconst getApproval = async (\n  token: string,\n  user: string,\n  spender: string,\n  amountWei: string\n): Promise<GetApprovalReturn> => {\n  if (token === ethToken)\n    return { allowanceWei: '', isApprovalRequired: false };\n\n  const tokenContract = Token__factory.connect(token, web3.provider);\n  const allowanceWei = (\n    await tokenContract.allowance(user, spender)\n  ).toString();\n\n  const isApprovalRequired = new BigNumber(amountWei).gt(\n    new BigNumber(allowanceWei)\n  );\n  return { allowanceWei, isApprovalRequired };\n};\n\nconst setApproval = async (\n  token: string,\n  user: string,\n  spender: string,\n  amountWei?: string,\n  resolveImmediately?: boolean\n): Promise<string> => {\n  const isEth = token === ethToken;\n  if (isEth) return '';\n\n  const tokenContract = Token__factory.connect(token, writeWeb3.signer);\n\n  const amountFinal = amountWei ? amountWei : UNLIMITED_WEI;\n\n  const isNullApprovalContract = NULL_APPROVAL_CONTRACTS.includes(token);\n\n  if (isNullApprovalContract) {\n    const { allowanceWei } = await getApproval(\n      token,\n      user,\n      spender,\n      amountFinal\n    );\n    if (Number(allowanceWei) !== 0) {\n      const tx = await tokenContract.approve(spender, '0');\n      await tx.wait();\n    }\n  }\n\n  try {\n    const tx = await tokenContract.approve(spender, amountFinal);\n    if (!resolveImmediately) await tx.wait();\n    return tx.hash;\n  } catch (e: any) {\n    const isTxDenied = e.message.toLowerCase().includes('denied');\n\n    if (!isTxDenied) {\n      // TODO send this error with failed contract to Sentry or GTM\n      NULL_APPROVAL_CONTRACTS.push(token);\n      console.error(\n        'Approval had failed, next try forcing a zero approval in case required',\n        e.message\n      );\n    }\n\n    throw e;\n  }\n};\n\nexport const getNetworkContractApproval = async (\n  token: Token,\n  contract: ApprovalContract | string,\n  amount: string\n): Promise<boolean> => {\n  const user = await user$.pipe(take(1)).toPromise();\n  const amountWei = expandToken(amount, token.decimals);\n  const { isApprovalRequired } = await getApproval(\n    token.address,\n    user,\n    await getApprovalAddress(contract),\n    amountWei\n  );\n  return isApprovalRequired;\n};\n\nexport const setNetworkContractApproval = async (\n  token: Token,\n  contract: ApprovalContract | string,\n  amount?: string,\n  resolveImmediately?: boolean\n) => {\n  const user = await user$.pipe(take(1)).toPromise();\n  const amountWei = amount ? expandToken(amount, token.decimals) : undefined;\n  return await setApproval(\n    token.address,\n    user,\n    await getApprovalAddress(contract),\n    amountWei,\n    resolveImmediately\n  );\n};\n\nconst getApprovalAddress = async (\n  contract: ApprovalContract | string\n): Promise<string> => {\n  if (typeof contract === 'string') return contract;\n\n  switch (contract) {\n    case ApprovalContract.BancorNetwork:\n      return await bancorNetwork$.pipe(take(1)).toPromise();\n    case ApprovalContract.ExchangeProxy:\n      return await exchangeProxy$.pipe(take(1)).toPromise();\n    case ApprovalContract.LiquidityProtection:\n      return await liquidityProtection$.pipe(take(1)).toPromise();\n    case ApprovalContract.Governance:\n      const network = await currentNetwork$.pipe(take(1)).toPromise();\n      return getNetworkVariables(network).governanceContractAddress;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}