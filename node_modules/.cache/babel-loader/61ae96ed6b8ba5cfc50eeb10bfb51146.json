{"ast":null,"code":"import { bancorNetwork$ } from 'services/observables/contracts';\nimport { web3, writeWeb3 } from 'services/web3';\nimport { bntToken, changeGas, ethToken, wethToken, zeroAddress } from 'services/web3/config';\nimport { take } from 'rxjs/operators';\nimport BigNumber from 'bignumber.js';\nimport { apiData$ } from 'services/observables/pools';\nimport { currentNetwork$ } from 'services/observables/network';\nimport { ConversionEvents, sendConversionEvent } from 'services/api/googleTagManager';\nimport { calcReserve, expandToken, shrinkToken } from 'utils/formulas';\nimport { ppmToDec } from 'utils/helperFunctions';\nimport { BancorNetwork__factory, Converter__factory } from '../abis/types';\nimport { multicall } from '../multicall/multicall';\nimport { ErrorCode } from '../types';\nexport const getRateAndPriceImapct = async (fromToken, toToken, amount) => {\n  try {\n    const networkContractAddress = await bancorNetwork$.pipe(take(1)).toPromise();\n    const contract = BancorNetwork__factory.connect(networkContractAddress, web3.provider);\n    const from = fromToken.address === wethToken ? { ...fromToken,\n      address: ethToken\n    } : fromToken;\n    const to = toToken.address === wethToken ? { ...toToken,\n      address: ethToken\n    } : toToken;\n    const path = await contract.conversionPath(from.address, to.address);\n    const fromAmountWei = expandToken(amount, fromToken.decimals);\n    const rateShape = {\n      contractAddress: contract.address,\n      interface: contract.interface,\n      methodName: 'rateByPath',\n      methodParameters: [path, fromAmountWei]\n    };\n    const spotRate = await calculateSpotPriceAndRate(fromToken, to, rateShape);\n    const rate = shrinkToken(spotRate.rate, toToken.decimals);\n    const priceImpactNum = new BigNumber(1).minus(new BigNumber(rate).div(amount).div(spotRate.spotPrice)).times(100);\n    return {\n      rate,\n      priceImpact: isNaN(priceImpactNum.toNumber()) ? '0.0000' : priceImpactNum.toFixed(4)\n    };\n  } catch (error) {\n    console.error('Failed fetching rate and price impact: ', error);\n    return {\n      rate: '0',\n      priceImpact: '0.0000'\n    };\n  }\n};\nexport const getRate = async (fromToken, toToken, amount) => {\n  try {\n    const networkContractAddress = await bancorNetwork$.pipe(take(1)).toPromise();\n    const contract = BancorNetwork__factory.connect(networkContractAddress, web3.provider);\n    const from = fromToken.address === wethToken ? ethToken : fromToken.address;\n    const to = toToken.address === wethToken ? ethToken : toToken.address;\n    const path = await contract.conversionPath(from, to);\n    const fromAmountWei = expandToken(amount, fromToken.decimals);\n    const toAmountWei = await contract.rateByPath(path, fromAmountWei);\n    return shrinkToken(toAmountWei.toString(), toToken.decimals);\n  } catch (error) {\n    console.error('Failed fetching rate', error);\n    return {\n      rate: '0',\n      priceImpact: '0.0000'\n    };\n  }\n};\n\nconst calculateMinimumReturn = (expectedWei, slippageTolerance) => {\n  const res = new BigNumber(expectedWei).times(new BigNumber(1).minus(slippageTolerance)).toFixed(0);\n  return res === '0' ? '1' : res;\n};\n\nexport const swap = async (slippageTolerance, fromToken, toToken, fromAmount, toAmount, onHash, onCompleted, rejected, failed) => {\n  try {\n    const fromIsEth = fromToken.address === ethToken;\n    const networkContractAddress = await bancorNetwork$.pipe(take(1)).toPromise();\n    const contract = BancorNetwork__factory.connect(networkContractAddress, writeWeb3.signer);\n    const fromWei = expandToken(fromAmount, fromToken.decimals);\n    const expectedToWei = expandToken(toAmount, toToken.decimals);\n    const path = await findPath(fromToken.address, toToken.address);\n    sendConversionEvent(ConversionEvents.wallet_req);\n    const estimate = await contract.estimateGas.convertByPath(path, fromWei, calculateMinimumReturn(expectedToWei, slippageTolerance), zeroAddress, zeroAddress, 0, {\n      value: fromIsEth ? fromWei : undefined\n    });\n    const gasLimit = changeGas(estimate.toString());\n    const tx = await contract.convertByPath(path, fromWei, calculateMinimumReturn(expectedToWei, slippageTolerance), zeroAddress, zeroAddress, 0, {\n      value: fromIsEth ? fromWei : undefined,\n      gasLimit\n    });\n    sendConversionEvent(ConversionEvents.wallet_confirm, tx.hash);\n    onHash(tx.hash);\n    await tx.wait();\n    onCompleted();\n  } catch (e) {\n    console.error('Swap failed with error: ', e);\n    if (e.code === ErrorCode.DeniedTx) rejected();else failed(e.message);\n  }\n};\n\nconst findPath = async (from, to) => {\n  const network = await currentNetwork$.pipe(take(1)).toPromise();\n  if (from === bntToken(network)) return [from, (await findPoolByToken(to)).pool_dlt_id, to];\n  if (to === bntToken(network)) return [from, (await findPoolByToken(from)).pool_dlt_id, to];\n  return [from, (await findPoolByToken(from)).pool_dlt_id, bntToken(network), (await findPoolByToken(to)).pool_dlt_id, to];\n};\n\nconst calculateSpotPriceAndRate = async (from, to, rateShape) => {\n  const network = await currentNetwork$.pipe(take(1)).toPromise();\n  const bnt = bntToken(network);\n  let pool;\n  if (from.address === bnt) pool = await findPoolByToken(to.address);\n  if (to.address === bnt) pool = await findPoolByToken(from.address);\n\n  if (pool) {\n    const fromShape = buildTokenPoolCall(pool.converter_dlt_id, from.address);\n    const toShape = buildTokenPoolCall(pool.converter_dlt_id, to.address);\n    const mCall = [fromShape, toShape, rateShape];\n    const res = await multicall(mCall);\n\n    if (res && res.length === mCall.length) {\n      return {\n        spotPrice: calcReserve(shrinkToken(res[0].toString(), from.decimals), shrinkToken(res[1].toString(), to.decimals), ppmToDec(pool.fee)),\n        rate: res[2].toString()\n      };\n    }\n  } //First hop\n\n\n  const fromPool = await findPoolByToken(from.address);\n  const fromShape1 = buildTokenPoolCall(fromPool.converter_dlt_id, from.address);\n  const bntShape1 = buildTokenPoolCall(fromPool.converter_dlt_id, bnt); //Second hop\n\n  const toPool = await findPoolByToken(to.address);\n  const bntShape2 = buildTokenPoolCall(toPool.converter_dlt_id, bnt);\n  const toShape2 = buildTokenPoolCall(toPool.converter_dlt_id, to.address);\n  const mCall = [fromShape1, bntShape1, bntShape2, toShape2, rateShape];\n  const res = await multicall(mCall);\n\n  if (res && res.length === mCall.length) {\n    const spot1 = calcReserve(shrinkToken(res[0].toString(), from.decimals), shrinkToken(res[1].toString(), 18), ppmToDec(fromPool.fee));\n    const spot2 = calcReserve(shrinkToken(res[2].toString(), 18), shrinkToken(res[3].toString(), to.decimals), ppmToDec(toPool.fee));\n    return {\n      spotPrice: spot1.times(spot2),\n      rate: res[4].toString()\n    };\n  }\n\n  return {\n    rate: '0',\n    spotPrice: new BigNumber(0)\n  };\n};\n\nexport const buildTokenPoolCall = (contractAddress, tokenAddress) => {\n  const contract = Converter__factory.connect(contractAddress, web3.provider);\n  return {\n    contractAddress: contract.address,\n    interface: contract.interface,\n    methodName: 'getConnectorBalance',\n    methodParameters: [tokenAddress]\n  };\n};\n\nconst findPoolByToken = async tkn => {\n  const apiData = await apiData$.pipe(take(1)).toPromise();\n  const pool = apiData.pools.find(x => x && x.reserves.find(x => x.address === tkn));\n  if (pool) return pool;\n  throw new Error('No pool found');\n};","map":{"version":3,"sources":["/Users/safahi/Desktop/webapp-v2-feature-gtm_events/src/services/web3/swap/market.ts"],"names":["bancorNetwork$","web3","writeWeb3","bntToken","changeGas","ethToken","wethToken","zeroAddress","take","BigNumber","apiData$","currentNetwork$","ConversionEvents","sendConversionEvent","calcReserve","expandToken","shrinkToken","ppmToDec","BancorNetwork__factory","Converter__factory","multicall","ErrorCode","getRateAndPriceImapct","fromToken","toToken","amount","networkContractAddress","pipe","toPromise","contract","connect","provider","from","address","to","path","conversionPath","fromAmountWei","decimals","rateShape","contractAddress","interface","methodName","methodParameters","spotRate","calculateSpotPriceAndRate","rate","priceImpactNum","minus","div","spotPrice","times","priceImpact","isNaN","toNumber","toFixed","error","console","getRate","toAmountWei","rateByPath","toString","calculateMinimumReturn","expectedWei","slippageTolerance","res","swap","fromAmount","toAmount","onHash","onCompleted","rejected","failed","fromIsEth","signer","fromWei","expectedToWei","findPath","wallet_req","estimate","estimateGas","convertByPath","value","undefined","gasLimit","tx","wallet_confirm","hash","wait","e","code","DeniedTx","message","network","findPoolByToken","pool_dlt_id","bnt","pool","fromShape","buildTokenPoolCall","converter_dlt_id","toShape","mCall","length","fee","fromPool","fromShape1","bntShape1","toPool","bntShape2","toShape2","spot1","spot2","tokenAddress","tkn","apiData","pools","find","x","reserves","Error"],"mappings":"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","sourcesContent":["import { bancorNetwork$ } from 'services/observables/contracts';\nimport { Token } from 'services/observables/tokens';\nimport { web3, writeWeb3 } from 'services/web3';\nimport {\n  bntToken,\n  changeGas,\n  ethToken,\n  wethToken,\n  zeroAddress,\n} from 'services/web3/config';\nimport { take } from 'rxjs/operators';\nimport BigNumber from 'bignumber.js';\nimport { apiData$ } from 'services/observables/pools';\nimport { APIPool } from 'services/api/bancor';\nimport { currentNetwork$ } from 'services/observables/network';\nimport {\n  ConversionEvents,\n  sendConversionEvent,\n} from 'services/api/googleTagManager';\nimport { calcReserve, expandToken, shrinkToken } from 'utils/formulas';\nimport { ppmToDec } from 'utils/helperFunctions';\nimport { BancorNetwork__factory, Converter__factory } from '../abis/types';\nimport { MultiCall as MCInterface, multicall } from '../multicall/multicall';\nimport { ErrorCode } from '../types';\n\nexport const getRateAndPriceImapct = async (\n  fromToken: Token,\n  toToken: Token,\n  amount: string\n) => {\n  try {\n    const networkContractAddress = await bancorNetwork$\n      .pipe(take(1))\n      .toPromise();\n\n    const contract = BancorNetwork__factory.connect(\n      networkContractAddress,\n      web3.provider\n    );\n\n    const from =\n      fromToken.address === wethToken\n        ? { ...fromToken, address: ethToken }\n        : fromToken;\n    const to =\n      toToken.address === wethToken\n        ? { ...toToken, address: ethToken }\n        : toToken;\n\n    const path = await contract.conversionPath(from.address, to.address);\n\n    const fromAmountWei = expandToken(amount, fromToken.decimals);\n    const rateShape: MCInterface = {\n      contractAddress: contract.address,\n      interface: contract.interface,\n      methodName: 'rateByPath',\n      methodParameters: [path, fromAmountWei],\n    };\n\n    const spotRate = await calculateSpotPriceAndRate(fromToken, to, rateShape);\n    const rate = shrinkToken(spotRate.rate, toToken.decimals);\n\n    const priceImpactNum = new BigNumber(1)\n      .minus(new BigNumber(rate).div(amount).div(spotRate.spotPrice))\n      .times(100);\n\n    return {\n      rate,\n      priceImpact: isNaN(priceImpactNum.toNumber())\n        ? '0.0000'\n        : priceImpactNum.toFixed(4),\n    };\n  } catch (error) {\n    console.error('Failed fetching rate and price impact: ', error);\n    return { rate: '0', priceImpact: '0.0000' };\n  }\n};\n\nexport const getRate = async (\n  fromToken: Token,\n  toToken: Token,\n  amount: string\n) => {\n  try {\n    const networkContractAddress = await bancorNetwork$\n      .pipe(take(1))\n      .toPromise();\n\n    const contract = BancorNetwork__factory.connect(\n      networkContractAddress,\n      web3.provider\n    );\n\n    const from = fromToken.address === wethToken ? ethToken : fromToken.address;\n    const to = toToken.address === wethToken ? ethToken : toToken.address;\n\n    const path = await contract.conversionPath(from, to);\n\n    const fromAmountWei = expandToken(amount, fromToken.decimals);\n    const toAmountWei = await contract.rateByPath(path, fromAmountWei);\n    return shrinkToken(toAmountWei.toString(), toToken.decimals);\n  } catch (error) {\n    console.error('Failed fetching rate', error);\n    return { rate: '0', priceImpact: '0.0000' };\n  }\n};\n\nconst calculateMinimumReturn = (\n  expectedWei: string,\n  slippageTolerance: number\n): string => {\n  const res = new BigNumber(expectedWei)\n    .times(new BigNumber(1).minus(slippageTolerance))\n    .toFixed(0);\n\n  return res === '0' ? '1' : res;\n};\n\nexport const swap = async (\n  slippageTolerance: number,\n  fromToken: Token,\n  toToken: Token,\n  fromAmount: string,\n  toAmount: string,\n  onHash: (txHash: string) => void,\n  onCompleted: Function,\n  rejected: Function,\n  failed: (error: string) => void\n) => {\n  try {\n    const fromIsEth = fromToken.address === ethToken;\n    const networkContractAddress = await bancorNetwork$\n      .pipe(take(1))\n      .toPromise();\n\n    const contract = BancorNetwork__factory.connect(\n      networkContractAddress,\n      writeWeb3.signer\n    );\n\n    const fromWei = expandToken(fromAmount, fromToken.decimals);\n    const expectedToWei = expandToken(toAmount, toToken.decimals);\n    const path = await findPath(fromToken.address, toToken.address);\n\n    sendConversionEvent(ConversionEvents.wallet_req);\n\n    const estimate = await contract.estimateGas.convertByPath(\n      path,\n      fromWei,\n      calculateMinimumReturn(expectedToWei, slippageTolerance),\n      zeroAddress,\n      zeroAddress,\n      0,\n      { value: fromIsEth ? fromWei : undefined }\n    );\n    const gasLimit = changeGas(estimate.toString());\n\n    const tx = await contract.convertByPath(\n      path,\n      fromWei,\n      calculateMinimumReturn(expectedToWei, slippageTolerance),\n      zeroAddress,\n      zeroAddress,\n      0,\n      { value: fromIsEth ? fromWei : undefined, gasLimit }\n    );\n\n    sendConversionEvent(ConversionEvents.wallet_confirm, tx.hash);\n\n    onHash(tx.hash);\n    await tx.wait();\n    onCompleted();\n  } catch (e: any) {\n    console.error('Swap failed with error: ', e);\n\n    if (e.code === ErrorCode.DeniedTx) rejected();\n    else failed(e.message);\n  }\n};\n\nconst findPath = async (from: string, to: string) => {\n  const network = await currentNetwork$.pipe(take(1)).toPromise();\n  if (from === bntToken(network))\n    return [from, (await findPoolByToken(to)).pool_dlt_id, to];\n\n  if (to === bntToken(network))\n    return [from, (await findPoolByToken(from)).pool_dlt_id, to];\n\n  return [\n    from,\n    (await findPoolByToken(from)).pool_dlt_id,\n    bntToken(network),\n    (await findPoolByToken(to)).pool_dlt_id,\n    to,\n  ];\n};\n\nconst calculateSpotPriceAndRate = async (\n  from: Token,\n  to: Token,\n  rateShape: MCInterface\n) => {\n  const network = await currentNetwork$.pipe(take(1)).toPromise();\n\n  const bnt = bntToken(network);\n  let pool;\n  if (from.address === bnt) pool = await findPoolByToken(to.address);\n  if (to.address === bnt) pool = await findPoolByToken(from.address);\n\n  if (pool) {\n    const fromShape = buildTokenPoolCall(pool.converter_dlt_id, from.address);\n    const toShape = buildTokenPoolCall(pool.converter_dlt_id, to.address);\n\n    const mCall = [fromShape, toShape, rateShape];\n    const res = await multicall(mCall);\n\n    if (res && res.length === mCall.length) {\n      return {\n        spotPrice: calcReserve(\n          shrinkToken(res[0].toString(), from.decimals),\n          shrinkToken(res[1].toString(), to.decimals),\n          ppmToDec(pool.fee)\n        ),\n        rate: res[2].toString(),\n      };\n    }\n  }\n\n  //First hop\n  const fromPool = await findPoolByToken(from.address);\n  const fromShape1 = buildTokenPoolCall(\n    fromPool.converter_dlt_id,\n    from.address\n  );\n  const bntShape1 = buildTokenPoolCall(fromPool.converter_dlt_id, bnt);\n\n  //Second hop\n  const toPool = await findPoolByToken(to.address);\n  const bntShape2 = buildTokenPoolCall(toPool.converter_dlt_id, bnt);\n  const toShape2 = buildTokenPoolCall(toPool.converter_dlt_id, to.address);\n\n  const mCall = [fromShape1, bntShape1, bntShape2, toShape2, rateShape];\n  const res = await multicall(mCall);\n\n  if (res && res.length === mCall.length) {\n    const spot1 = calcReserve(\n      shrinkToken(res[0].toString(), from.decimals),\n      shrinkToken(res[1].toString(), 18),\n      ppmToDec(fromPool.fee)\n    );\n\n    const spot2 = calcReserve(\n      shrinkToken(res[2].toString(), 18),\n      shrinkToken(res[3].toString(), to.decimals),\n      ppmToDec(toPool.fee)\n    );\n\n    return { spotPrice: spot1.times(spot2), rate: res[4].toString() };\n  }\n\n  return { rate: '0', spotPrice: new BigNumber(0) };\n};\n\nexport const buildTokenPoolCall = (\n  contractAddress: string,\n  tokenAddress: string\n): MCInterface => {\n  const contract = Converter__factory.connect(contractAddress, web3.provider);\n\n  return {\n    contractAddress: contract.address,\n    interface: contract.interface,\n    methodName: 'getConnectorBalance',\n    methodParameters: [tokenAddress],\n  };\n};\n\nconst findPoolByToken = async (tkn: string): Promise<APIPool> => {\n  const apiData = await apiData$.pipe(take(1)).toPromise();\n\n  const pool = apiData.pools.find(\n    (x) => x && x.reserves.find((x) => x.address === tkn)\n  );\n  if (pool) return pool;\n\n  throw new Error('No pool found');\n};\n"]},"metadata":{},"sourceType":"module"}