{"ast":null,"code":"import { take } from 'rxjs/operators';\nimport { liquidityProtection$, liquidityProtectionStore$ } from 'services/observables/contracts';\nimport dayjs from 'utils/dayjs';\nimport { web3, writeWeb3 } from 'services/web3';\nimport { LiquidityProtectionStore__factory, LiquidityProtection__factory } from '../abis/types';\nimport { ErrorCode } from '../types';\nimport { shrinkToken } from 'utils/formulas';\nimport { partition } from 'lodash';\nexport const fetchLockedAvailableBalances = async user => {\n  try {\n    const storeAddress = await liquidityProtectionStore$.pipe(take(1)).toPromise();\n    const contract = LiquidityProtectionStore__factory.connect(storeAddress, web3.provider);\n    const lockedBalanceCount = Number(await contract.lockedBalanceCount(user));\n    if (lockedBalanceCount === 0) return;\n    const lockedBalances = await contract.lockedBalanceRange(user, 0, lockedBalanceCount);\n    const bnts = lockedBalances['0'];\n    const expirys = lockedBalances['1'];\n    const res = bnts.map((bnt, index) => ({\n      bnt: Number(shrinkToken(bnt.toString(), 18)),\n      expiry: Number(expirys[index])\n    }));\n    const now = dayjs().unix() * 1000;\n    const [available, locked] = partition(res, x => dayjs.unix(x.expiry).isBefore(now));\n    const totalAvailable = available.length === 0 ? 0 : available.map(x => x.bnt).reduce((item, prev) => item + prev);\n    return {\n      locked: locked.map(x => ({ ...x,\n        expiry: x.expiry * 1000\n      })),\n      available: totalAvailable\n    };\n  } catch (error) {\n    console.error(error);\n  }\n};\nexport const claimBnt = async (onHash, onCompleted, rejected, failed) => {\n  try {\n    const liquidityProtectionContract = await liquidityProtection$.pipe(take(1)).toPromise();\n    const contract = LiquidityProtection__factory.connect(liquidityProtectionContract, writeWeb3.signer);\n    const tx = await contract.claimBalance('0', '1000');\n    onHash(tx.hash);\n    await tx.wait();\n    onCompleted();\n  } catch (e) {\n    if (e.code === ErrorCode.DeniedTx) rejected();else failed(e.message);\n  }\n};","map":{"version":3,"sources":["/Users/safahi/Desktop/webapp-v2-feature-gtm_events/src/services/web3/lockedbnt/lockedbnt.ts"],"names":["take","liquidityProtection$","liquidityProtectionStore$","dayjs","web3","writeWeb3","LiquidityProtectionStore__factory","LiquidityProtection__factory","ErrorCode","shrinkToken","partition","fetchLockedAvailableBalances","user","storeAddress","pipe","toPromise","contract","connect","provider","lockedBalanceCount","Number","lockedBalances","lockedBalanceRange","bnts","expirys","res","map","bnt","index","toString","expiry","now","unix","available","locked","x","isBefore","totalAvailable","length","reduce","item","prev","error","console","claimBnt","onHash","onCompleted","rejected","failed","liquidityProtectionContract","signer","tx","claimBalance","hash","wait","e","code","DeniedTx","message"],"mappings":"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","sourcesContent":["import { take } from 'rxjs/operators';\nimport {\n  liquidityProtection$,\n  liquidityProtectionStore$,\n} from 'services/observables/contracts';\nimport dayjs from 'utils/dayjs';\nimport { web3, writeWeb3 } from 'services/web3';\nimport {\n  LiquidityProtectionStore__factory,\n  LiquidityProtection__factory,\n} from '../abis/types';\nimport { ErrorCode } from '../types';\nimport { shrinkToken } from 'utils/formulas';\nimport { partition } from 'lodash';\n\nexport interface LockedBnt {\n  bnt: number;\n  expiry: number;\n}\n\nexport interface LockedAvailableBnt {\n  locked: LockedBnt[];\n  available: number;\n}\n\nexport const fetchLockedAvailableBalances = async (\n  user: string\n): Promise<LockedAvailableBnt | undefined> => {\n  try {\n    const storeAddress = await liquidityProtectionStore$\n      .pipe(take(1))\n      .toPromise();\n    const contract = LiquidityProtectionStore__factory.connect(\n      storeAddress,\n      web3.provider\n    );\n\n    const lockedBalanceCount = Number(await contract.lockedBalanceCount(user));\n    if (lockedBalanceCount === 0) return;\n\n    const lockedBalances = await contract.lockedBalanceRange(\n      user,\n      0,\n      lockedBalanceCount\n    );\n\n    const bnts = lockedBalances['0'];\n    const expirys = lockedBalances['1'];\n\n    const res = bnts.map((bnt, index) => ({\n      bnt: Number(shrinkToken(bnt.toString(), 18)),\n      expiry: Number(expirys[index]),\n    }));\n\n    const now = dayjs().unix() * 1000;\n    const [available, locked] = partition(res, (x) =>\n      dayjs.unix(x.expiry).isBefore(now)\n    );\n\n    const totalAvailable =\n      available.length === 0\n        ? 0\n        : available.map((x) => x.bnt).reduce((item, prev) => item + prev);\n\n    return {\n      locked: locked.map((x) => ({ ...x, expiry: x.expiry * 1000 })),\n      available: totalAvailable,\n    };\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nexport const claimBnt = async (\n  onHash: (txHash: string) => void,\n  onCompleted: Function,\n  rejected: Function,\n  failed: (error: string) => void\n) => {\n  try {\n    const liquidityProtectionContract = await liquidityProtection$\n      .pipe(take(1))\n      .toPromise();\n    const contract = LiquidityProtection__factory.connect(\n      liquidityProtectionContract,\n      writeWeb3.signer\n    );\n\n    const tx = await contract.claimBalance('0', '1000');\n    onHash(tx.hash);\n\n    await tx.wait();\n    onCompleted();\n  } catch (e: any) {\n    if (e.code === ErrorCode.DeniedTx) rejected();\n    else failed(e.message);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}